use anyhow::Result;
use clap::ValueEnum;
use log::info;
use std::collections::HashMap;
use tokio::fs;

use crate::scanner::ScanResult;

#[derive(ValueEnum, Clone, Debug)]
pub enum ExportFormat {
    Json,
    Markdown,
    Csv,
}

pub async fn export_results(
    results: &[ScanResult],
    report: &HashMap<String, String>,
    format: ExportFormat,
    output_path: Option<String>,
) -> Result<()> {
    let content = match format {
        ExportFormat::Json => export_to_json(results, report)?,
        ExportFormat::Markdown => export_to_markdown(results, report),
        ExportFormat::Csv => export_to_csv(results),
    };

    match output_path {
        Some(path) => {
            fs::write(&path, content).await?;
            info!("üìÅ Results exported to: {path}");
        }
        None => {
            println!("{content}");
        }
    }

    Ok(())
}

fn export_to_json(results: &[ScanResult], report: &HashMap<String, String>) -> Result<String> {
    let output = serde_json::json!({
        "scan_info": report,
        "results": results.iter().filter(|r| r.is_open).collect::<Vec<_>>()
    });

    Ok(serde_json::to_string_pretty(&output)?)
}

fn export_to_markdown(results: &[ScanResult], report: &HashMap<String, String>) -> String {
    let mut output = String::new();

    // Header
    output.push_str("# üîç NullScan Report\n\n");

    // Scan information
    output.push_str("## üìä Scan Information\n\n");
    output.push_str(&format!(
        "- **Target:** {}\n",
        report.get("target").unwrap_or(&"Unknown".to_string())
    ));
    output.push_str(&format!(
        "- **Total Ports Scanned:** {}\n",
        report.get("total_ports").unwrap_or(&"0".to_string())
    ));
    output.push_str(&format!(
        "- **Open Ports:** {}\n",
        report.get("open_ports").unwrap_or(&"0".to_string())
    ));
    output.push_str(&format!(
        "- **Closed Ports:** {}\n",
        report.get("closed_ports").unwrap_or(&"0".to_string())
    ));
    output.push_str(&format!(
        "- **Scan Duration:** {}\n",
        report
            .get("scan_duration")
            .unwrap_or(&"Unknown".to_string())
    ));
    output.push_str(&format!(
        "- **Timestamp:** {}\n\n",
        report.get("timestamp").unwrap_or(&"Unknown".to_string())
    ));

    // Open ports
    let open_ports: Vec<_> = results.iter().filter(|r| r.is_open).collect();

    if open_ports.is_empty() {
        output.push_str("## üö´ No Open Ports Found\n\n");
        output.push_str("All scanned ports were closed or filtered.\n");
    } else {
        output.push_str("## üü¢ Open Ports\n\n");
        output.push_str("| Port | Service | Banner | Response Time |\n");
        output.push_str("|------|---------|--------|--------------|\n");

        for result in open_ports {
            let service = result.service.as_deref().unwrap_or("Unknown");
            let banner = result.banner.as_deref().unwrap_or("N/A");
            let response_time = format!("{}ms", result.response_time.as_millis());

            output.push_str(&format!(
                "| {} | {} | {} | {} |\n",
                result.port,
                service,
                banner.replace('|', "\\|"), // Escape pipes for markdown
                response_time
            ));
        }
    }

    output.push_str("\n---\n");
    output.push_str("*Generated by NullScan v1.0.0*\n");

    output
}

fn export_to_csv(results: &[ScanResult]) -> String {
    let mut output = String::new();

    // Header
    output.push_str("Port,Status,Service,Banner,ResponseTime(ms)\n");

    // Data
    for result in results.iter().filter(|r| r.is_open) {
        let service = result.service.as_deref().unwrap_or("Unknown");
        let banner = result.banner.as_deref().unwrap_or("N/A");
        let response_time = result.response_time.as_millis();

        output.push_str(&format!(
            "{},Open,\"{}\",\"{}\",{}\n",
            result.port,
            service,
            banner.replace('"', "\"\""), // Escape quotes for CSV
            response_time
        ));
    }

    output
}
